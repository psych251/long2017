theme(panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))  +
scale_color_manual(values = c("#00AFBB", "#FC4E07"))
p <- ggplot(fvs, aes(x = age,y = hand.look, color = condition)) +
geom_point() +
geom_smooth() +
ylab("Time spent looking at hands") +
xlab("Age (months)") +
scale_color_discrete(name="Condition",
breaks=c("Faces_Medium", "Faces_Plus"),
labels=c("Simple Scene", "Complex Scene")) +
theme(panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))  +
scale_color_manual(values = c("#00AFBB", "#FC4E07"))
What do you conclude from this pattern of data?
ggplot(fvs, aes(x = age,y = hand.look, color = condition)) +
geom_point() +
geom_smooth() +
ylab("Time spent looking at hands") +
xlab("Age (months)") +
scale_color_discrete(name="Condition",
breaks=c("Faces_Medium", "Faces_Plus"),
labels=c("Simple Scene", "Complex Scene")) +
theme(panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))  +
scale_color_manual(values = c("#00AFBB", "#FC4E07"))
ggplot(fvs, aes(x = age,y = hand.look, color = condition)) +
geom_point() +
geom_smooth() +
ylab("Time spent looking at hands") +
xlab("Age (months)") +
scale_color_discrete(name="Condition",
breaks=c("Faces_Medium", "Faces_Plus"),
labels=c("Simple Scene", "Complex Scene")) +
theme(panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))  +
scale_color_manual(values = c("#00AFBB", "#FC4E07")) +
scale_x_continuous(0,30,5)
ggplot(fvs, aes(x = age,y = hand.look, color = condition)) +
geom_point() +
geom_smooth() +
ylab("Time spent looking at hands") +
xlab("Age (months)") +
scale_color_discrete(name="Condition",
breaks=c("Faces_Medium", "Faces_Plus"),
labels=c("Simple Scene", "Complex Scene")) +
theme(panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))  +
scale_color_manual(values = c("#00AFBB", "#FC4E07")) +
scale_x_continuous(breaks=seq(0,30,5))
ggplot(fvs, aes(x = age,y = hand.look, color = condition)) +
geom_point() +
geom_smooth() +
ylab("Time spent looking at hands") +
xlab("Age (months)") +
theme(panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))  +
scale_color_manual(values = c("#00AFBB", "#FC4E07")) +
scale_x_continuous(breaks=seq(0,30,5)) +
scale_color_discrete(name="Condition",
breaks=c("Faces_Medium", "Faces_Plus"),
labels=c("Simple Scene", "Complex Scene"))
p <- ggplot(fvs, aes(x = age,y = hand.look, color = condition)) +
geom_point() +
geom_smooth() +
ylab("Time spent looking at hands") +
xlab("Age (months)") +
theme(panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))  +
scale_x_continuous(breaks=seq(0,30,5)) +
scale_color_discrete(name="Condition",
breaks=c("Faces_Medium", "Faces_Plus"),
labels=c("Simple Scene", "Complex Scene"))
p + scale_color_manual(values = c("#00AFBB", "#FC4E07")) +
p + scale_color_manual(values = c("#00AFBB", "#FC4E07"))
p <- ggplot(fvs, aes(x = age,y = hand.look, color = condition)) +
geom_point() +
geom_smooth() +
ylab("Time spent looking at hands") +
xlab("Age (months)") +
theme(panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))  +
scale_x_continuous(breaks=seq(0,30,5)) +
scale_color_discrete(name="Condition",
breaks=c("Faces_Medium", "Faces_Plus"),
labels=c("Simple Scene", "Complex Scene"))
p + scale_color_manual(values = c("#00AFBB", "#FC4E07"))
p + scale_color_manual(values = c("#00AFBB", "#FC4E07"),
name="Condition",
breaks=c("Faces_Medium", "Faces_Plus"),
labels=c("Simple Scene", "Complex Scene"))
ggplot(fvs, aes(x = age,y = hand.look, color = condition)) +
geom_point() +
geom_smooth() +
ylab("Time spent looking at hands") +
xlab("Age (months)") +
theme(panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))  +
scale_x_continuous(breaks=seq(0,30,5)) +
scale_color_manual(values = c("#00AFBB", "#FC4E07"),
name="Condition",
breaks=c("Faces_Medium", "Faces_Plus"),
labels=c("Simple Scene", "Complex Scene"))
t.test(rnorm,30)
rnorm.30
rnorm(30)
t.testt(rnorm(30))
t.test(rnorm(30))
t.test(rnorm(30)).p-value
t.test(rnorm(30))$p
t.test(rnorm(30))$p.value
for i = 1:10000 {
for (i in (1:10000)) {
x = ttest(rnorm(30))$p.value
if (x < 0.05) {
sig = sig+ 1
}
}
x = t.test(rnorm(30))$p.value
for (i in (1:10000)) {
x = t.test(rnorm(30))$p.value
if (x < 0.05) {
sig = sig+ 1
}
}
sig = 0
for (i in (1:10000)) {
x = t.test(rnorm(30))$p.value
if (x < 0.05) {
sig = sig+ 1
}
}
proportionSig = sig/10000
replicate(10,rnorm(30))
t.test(replicate(rnorm(30)))
t.test(replicate(rnorm(30)))
t.test(replicate(rnorm(30)))
t.test(replicate(2,rnorm(30)))
t.test(replicate(2,rnorm(30)))$p.value
replicate(10, t.test(rnorm(30)))
replicate(10, t.test(rnorm(30))$p.value)
tmp <- replicate(10, t.test(rnorm(30))$p.value)
tmp > 0.05
sum(tmp > 0.05)
proportionReplicate = sum(k < 0.05)/10000
k <- replicate(10000, t.test(rnorm(30))$p.value)
proportionReplicate = sum(k < 0.05)/10000
firstSample = rnorm(30)
firstP <- t.test(firstSample))$p.value
t.test(firstSampe)
t.test(firstSample)
firstP <- t.test(firstSample)$p.value
if (firstP < 0.25 | firstP > 0.05) {
}
if (currentP < 0.25 &  currenttP > 0.05) {
newSample = rnorm(30)
currentSample = c(currentSample, newSample)
double.sample
}
return currentP
return(currentP)
double.sample <- function () {
firstSample = rnorm(30)
currentP <- t.test(firstSample)$p.value
if (currentP < 0.25 &  currentP > 0.05) {
newSample = rnorm(30)
currentSample = c(firstSample, newSample)
currentP = t.test(currentSample)$p.value
}
return(currentP)
}
replicate(10000,double.sample)
t.test(first.Sample)$p.value
t.test(firstSample)$p.value
newSample = rnorm(30)
currentSample = c(firstSample, newSample)
currentP<-t.test(currentSample)$p.value
double.sample
return(currentP)
double.sample <- function (firstSample) {
currentP <- t.test(firstSample)$p.value
if (currentP < 0.25 &  currentP > 0.05) {
newSample = rnorm(30)
currentSample = c(firstSample, newSample)
currentP<-t.test(currentSample)$p.value
}
return(currentP)
}
double.sample(rnorm(30))
size(rnorm(30))
length(rnorm(30))
replicate(10000,double.sample(rnorm(30)))
proportionOptional = sum(o < 0.05)/10000
o <- replicate(10000,double.sample(rnorm(30)))
proportionOptional = sum(o < 0.05)/10000
double.sample <- function (firstSample, upperP) {
currentP <- t.test(firstSample)$p.value
if (currentP < upperP &  currentP > 0.05) {
newSample = rnorm(lenth(firstSample))
currentSample = c(firstSample, newSample)
currentP<-t.test(currentSample)$p.value
}
return(currentP)
}
o <- replicate(10000,double.sample(rnorm(30), .25))
double.sample <- function (firstSample, upperP) {
currentP <- t.test(firstSample)$p.value
if (currentP < upperP &  currentP > 0.05) {
newSample = rnorm(length(firstSample))
currentSample = c(firstSample, newSample)
currentP<-t.test(currentSample)$p.value
}
return(currentP)
}
o <- replicate(10000,double.sample(rnorm(30), .25))
proportionOptional = sum(o < 0.05)/10000
sim25 <- replicate(10000,double.sample(rnorm(30), .25))
sim25 <- replicate(10000,double.sample(rnorm(30), .25))
proportionSim25 = sum(sim25 < 0.05)/10000
sim05 <- replicate(10000,double.sample(rnorm(30), 0.05))
proportionSim05 = sum(sim05 < 0.05)/10000
sim5 <- replicate(10000,double.sample(rnorm(30), 0.5))
proportionSim5 = sum(sim5 < 0.05)/10000
sim5 <- replicate(10000,double.sample(rnorm(30), 0.5))
sim5 <- replicate(10000,double.sample(rnorm(30), 0.5))
proportionSim5 = sum(sim5 < 0.05)/10000
sim75 <- replicate(10000,double.sample(rnorm(30), .75))
sim75 <- replicate(10000,double.sample(rnorm(30), .75))
proportionSim75 = sum(sim75 < 0.05)/10000
sim75 <- replicate(10000,double.sample(rnorm(30), .75))
sim75 <- replicate(10000,double.sample(rnorm(30), .75))
proportionSim75 = sum(sim75 < 0.05)/10000
simANY <- replicate(10000,double.sample(rnorm(30), 2))
simANY <- replicate(10000,double.sample(rnorm(30), 2))
proportionSimANY = sum(simANY < 0.05)/10000
sim5 <- replicate(10000,double.sample(rnorm(30), 0.5))
sim5 <- replicate(10000,double.sample(rnorm(30), 0.5))
proportionSim5 = sum(sim5 < 0.05)/10000
sim75 <- replicate(10000,double.sample(rnorm(30), .75))
sim75 <- replicate(10000,double.sample(rnorm(30), .75))
proportionSim75 = sum(sim75 < 0.05)/10000
simANY <- replicate(10000,double.sample(rnorm(30), 2))
simANY <- replicate(10000,double.sample(rnorm(30), 2))
proportionSimANY = sum(simANY < 0.05)/10000
sim25 <- replicate(10000,double.sample(rnorm(30), .25))
sim25 <- replicate(10000,double.sample(rnorm(30), .25))
proportionSim25 = sum(sim25 < 0.05)/10000
sim5 <- replicate(10000,double.sample(rnorm(30), 0.5))
sim5 <- replicate(10000,double.sample(rnorm(30), 0.5))
proportionSim5 = sum(sim5 < 0.05)/10000
proportionSim5 = sum(sim5 < 0.05)/10000
sim75 <- replicate(10000,double.sample(rnorm(30), .75))
sim5 <- replicate(10000,double.sample(rnorm(30), 0.5))
proportionSim5 = sum(sim5 < 0.05)/10000
sim75 <- replicate(10000,double.sample(rnorm(30), .75))
proportionSim75 = sum(sim75 < 0.05)/10000
proportionSim75 = sum(sim75 < 0.05)/10000
simANY <- replicate(10000,double.sample(rnorm(30), 2))
proportionSim75 = sum(sim75 < 0.05)/10000
simANY <- replicate(10000,double.sample(rnorm(30), 2))
proportionSimANY = sum(simANY < 0.05)/10000
currentSample
proportionSim5 = sum(sim5 < 0.05)/10000
```{r include=T}
library(WebPower)
90%  power
```{r include=T}
# 90% power
wp.rmanova(n = NULL, ng = 1, nm = 2, f = 0.95, nscor = 1,
alpha = 0.05, power = .9, type = 1)
```
100% power
```{r include=T}
wp.rmanova(n = NULL, ng = 1, nm = 2, f = 0.95, nscor = 1,
alpha = 0.05, power = .95, type = 1)
###Planned Sample
N = 16 (as in the original paper).
###Materials
"The stimulus set consisted of 60 texform images generated from images of 30 big, inanimate objects and 30 small, inanimate objects (see Fig. 2). Big objects included things like cars and tables and were chair-sized and bigger; Small objects included things like mugs and cameras, and were table-lamp sized and smaller. The texform stimuli were synthesized using an algorithm that preserves mid-level image features from the original images, such as local combinations of orientations (see Long et al., 2016 for more detailed description of the procedure; see also Freeman & Simoncelli, 2011)."
These materials are available at https://github.com/brialorelle/TexformSizeStroop.
###Procedure
###Data Preparation
####Load Relevant Libraries and Functions
library(tidyverse)
###Data Preparation
####Load Relevant Libraries and Functions
library(tidyverse)
library(ez)
library(stringi)
####Import data
df = read.csv("pilotB_results.csv")
####Import data
df = read.csv("pilotB_results.csv")
original_df = read.csv('~/git/long2017/original_paper/data/E1GroupData.csv')
task = character()
```{r include=T}
for (i in 1:NROW(df)) {# for each sub split data
subAccuracy=character()
subCongruency = character()
subTask = character()
subRT = character()
for (b in 1:4) {# for each block
# First we need to split our data for each trial becasue its in one long string
subAccuracy = c(subAccuracy, unlist(strsplit(toString(df[paste0("Answer.accuracy",b)][i,1]),",")))
subCongruency = c(subCongruency,unlist(strsplit(toString(df[paste0("Answer.congruency",b)][i,1]),",")))
subRT = c(subRT, unlist(strsplit(toString(df[paste0("Answer.rt",b)][i,1]),",")))
subTask = c(subTask,unlist(strsplit(toString(df[paste0("Answer.task",b)][i,1]),",")))
}
# remove empty rows
subAccuracy <- stri_remove_empty(subAccuracy, na_empty = FALSE)
subCongruency <- stri_remove_empty(subCongruency, na_empty = FALSE)
subRT <- stri_remove_empty(subRT, na_empty = FALSE)
subTask <- stri_remove_empty(subTask, na_empty = FALSE)
# re-code accuracy as 1s and 0s
subAccuracy <-
ifelse(subAccuracy == "correct", 1, ifelse(subAccuracy == "incorrect", 0, NA))
# Only include data in dataframe if  there  are more than 80% of trials correct.
if (sum(subAccuracy) >= .80*(480)){
accuracy = c(accuracy,subAccuracy)
congruency = c(congruency,subCongruency)
rt= c(rt,subRT)
task= c(task, subTask)
subject= c(subject, replicate(480,i))
}
rm(subAccuracy, subCongruency, subRT, subTask)
}
accuracy = character()
rt = character()
congruency = character()
subject = character()
task = character()
```{r include=T}
for (i in 1:NROW(df)) {# for each sub split data
subAccuracy=character()
subCongruency = character()
subTask = character()
subRT = character()
for (b in 1:4) {# for each block
# First we need to split our data for each trial becasue its in one long string
subAccuracy = c(subAccuracy, unlist(strsplit(toString(df[paste0("Answer.accuracy",b)][i,1]),",")))
subCongruency = c(subCongruency,unlist(strsplit(toString(df[paste0("Answer.congruency",b)][i,1]),",")))
subRT = c(subRT, unlist(strsplit(toString(df[paste0("Answer.rt",b)][i,1]),",")))
subTask = c(subTask,unlist(strsplit(toString(df[paste0("Answer.task",b)][i,1]),",")))
}
# remove empty rows
subAccuracy <- stri_remove_empty(subAccuracy, na_empty = FALSE)
subCongruency <- stri_remove_empty(subCongruency, na_empty = FALSE)
subRT <- stri_remove_empty(subRT, na_empty = FALSE)
subTask <- stri_remove_empty(subTask, na_empty = FALSE)
# re-code accuracy as 1s and 0s
subAccuracy <-
ifelse(subAccuracy == "correct", 1, ifelse(subAccuracy == "incorrect", 0, NA))
# Only include data in dataframe if  there  are more than 80% of trials correct.
if (sum(subAccuracy) >= .80*(480)){
accuracy = c(accuracy,subAccuracy)
congruency = c(congruency,subCongruency)
rt= c(rt,subRT)
task= c(task, subTask)
subject= c(subject, replicate(480,i))
}
rm(subAccuracy, subCongruency, subRT, subTask)
}
# convert rt to integers
rt = strtoi(rt);
# put everything in a new dataframe!
df_long <- data.frame(subject, accuracy, congruency, rt, task)
df_long$accuracy <- accuracy
df_long$congruency <- congruency
df_long$rt <- rt
df_long$task <- task
```{r include=T}
mean(original_df$RT)
sd(original_df$RT)
ggplot(original_df, aes(x = RT)) +
geom_histogram() +
xlim(0,2500)
mean(original_df$RT)
sd(original_df$RT)
ggplot(original_df, aes(x = RT)) +
geom_histogram() +
xlim(0,2500)
mean(df_long$rt)
sd(df_long$rt)
ggplot(df_long, aes(x = rt)) +
geom_histogram() +
xlim(0, 2500)
# trim data
DataTrimmed<- df_long[df_long$rt>1200 & df_long$rt<2200& df_long$accuracy == 1,]
originalDataTrimmed<-original_df[original_df$RT>200 & original_df$RT<1500 & original_df$isCorrect == 1,]
First, reporoduce original results.
```{r include=T}
originalAov.out  = ezANOVA(data = originalDataTrimmed, dv=.(RT), wid=.(sid), within=.(condLabel, taskNum), type=3)
print(originalAov.out)
```
Next, run the same analysis on replication data
```{r include=T}
aov.out = ezANOVA(data = DataTrimmed, dv=.(rt), wid=.(subject), within=.(congruency,task), type=3)
print(aov.out)
```
Prepare original data for plot:
First, we will get the means for each subject.
```{r include=T}
sidMeans <- originalDataTrimmed %>%
group_by(sid) %>%
summarize(meanRT = mean(RT))
```
Next get means for each condition.
```{r include=T}
origPlot <- originalDataTrimmed %>%
group_by(condLabel) %>%
summarize(meanRT = mean(RT), SEM = sd(RT)/sqrt(length(unique(originalDataTrimmed$sid))))
```
Next get means by subject/ condition
```{r include=T}
origTall <- originalDataTrimmed %>%
group_by(condLabel,sid) %>%
summarize(meanRT = mean(RT))
```
Make a wide form version the subjet/ condition table
```{r include=T}
origWide = pivot_wider(origTall,names_from= condLabel, values_from = meanRT)
```
Calculate repeated measures error, which they did in original paper.
```{r include=T}
congruentErr = sd(origWide$congruent - sidMeans$meanRT)/sqrt(length(origWide$congruent))
incongruentErr = sd(origWide$incongruent - sidMeans$meanRT)/sqrt(length(origWide$incongruent))
origPlot$SEM_repeated <- c(congruentErr, incongruentErr)
```
Prepare replication data for plot:
First, we will get the means for each subject.
```{r include=T}
rep_sidMeans <- DataTrimmed %>%
group_by(subject) %>%
summarize(meanRT = mean(rt))
```
Next, get means for each condition
```{r include=T}
repPlot <- DataTrimmed %>%
group_by(congruency) %>%
summarize(meanRT = mean(rt), SEM = sd(rt)/sqrt(length(unique(DataTrimmed$subject))))
```
Next, get means by subject/ condition
```{r include=T}
repTall <- DataTrimmed %>%
group_by(congruency,subject) %>%
summarize(meanRT = mean(rt))
```
Make a wide form version the subjet/ condition table
```{r include=T}
repWide = pivot_wider(repTall,names_from= congruency, values_from = meanRT)
```
Calculate repeated measures error, which they did in original paper.
```{r include=T}
congruentErr = sd(repWide$congruent - rep_sidMeans$meanRT)/sqrt(length(repWide$congruent))
incongruentErr = sd(repWide$incongruent - rep_sidMeans$meanRT)/sqrt(length(repWide$incongruent))
repPlot$SEM_repeated <- c(congruentErr, incongruentErr)
```
Original plot:
```{r include=T}
ggplot(origPlot, aes(x = condLabel, y=meanRT, fill=condLabel)) +
geom_bar(stat = "identity") +
scale_fill_manual(values=c("#336699", "#660000")) +
geom_errorbar(aes(ymin=meanRT-SEM_repeated, ymax=meanRT+SEM_repeated), width=.2,
position=position_dodge(.9)) +
theme(axis.title.x=element_blank(),
axis.ticks.x=element_blank()) +
theme(panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black")) +
theme(legend.position = "none") +
theme(text = element_text(size=20)) +
ylab("RT") +
coord_cartesian(ylim =(c(475,525)))
```
```{r include=T}
ggplot(repPlot, aes(x = congruency, y=meanRT, fill=congruency)) +
geom_bar(stat = "identity")  +
scale_fill_manual(values=c("#336699", "#660000")) +
geom_errorbar(aes(ymin=meanRT-SEM_repeated, ymax=meanRT+SEM_repeated), width=.2,
position=position_dodge(.9)) +
theme(axis.title.x=element_blank(),
axis.ticks.x=element_blank()) +
theme(panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black")) +
theme(legend.position = "none") +
theme(text = element_text(size=20)) +
ylab("RT") +
coord_cartesian(ylim =(c(1500,1550)))
ggplot(repPlot, aes(x = congruency, y=meanRT, fill=congruency)) +
geom_bar(stat = "identity")  +
scale_fill_manual(values=c("#336699", "#660000")) +
geom_errorbar(aes(ymin=meanRT-SEM_repeated, ymax=meanRT+SEM_repeated), width=.2,
position=position_dodge(.9)) +
theme(axis.title.x=element_blank(),
axis.ticks.x=element_blank()) +
theme(panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black")) +
theme(legend.position = "none") +
theme(text = element_text(size=20)) +
ylab("RT") +
coord_cartesian(ylim =(c(1500,1550)))
